/* Упаковать 0 и 1
   Написать функцию, которая сжимает серии массива, состоящего из единиц и нулей по следующему принципу: например, массив [0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1] преобразуется в [4,7,2,4] (т.к. начинается с нуля, то сразу записывается количество элементов первой серии); а массив [1,1,1,0,0,0,0,0,0,0] преобразуется в [0,3,7] (т.к. первая серия - это единицы, то первый элемент преобразованного массива 0).

   Необходимо реализовать только одну функцию, всю программу загружать не надо. Прототип функции: int compression(int a[], int b[], int N)
   Формат входных данных
   Функция принимает исходный массив a[] и сжимает в массив b[], N - число элементов в массиве a[].
   Формат результата
   Функция возвращает число элементов сжатого массива b[]
   Примеры
   Входные данные
   1 1 0 0 1 1 1 0 1 1 0 0 1 0 1 0 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 1 1 0 1 1 0 1 0 0 0 1 1 0 0 1 0 0 0 1 0 0 1 1 1 0 1 0 0 0 0 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0
   Результат работы
   [0,2,2,3,1,2,2,1,1,1,2,1,4,4,1,1,4,3,1,2,1,1,3,2,2,1,3,1,2,3,1,1,6,1,1,1,2,2,1,1,4,1,2,2,1,1,3,1,1,6,1,1,2]
   Входные данные
   0 0 1 0 0 1 1 0 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 1 0 1 0 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0 0 1 0 1 1 1 1 1 0 1 0 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 0 0 1 1 1 1 0 1 0 1 1
   Результат работы
   [2,1,2,2,2,2,1,1,2,2,1,1,1,4,1,4,4,2,2,1,1,1,1,3,1,1,1,2,1,3,4,1,1,1,3,1,1,5,1,1,1,3,3,1,1,4,1,3,2,4,1,1,1,2]

*/

//#define DEBUG
#ifdef DEBUG

#include <stdio.h>
#define size_arr 200
typedef unsigned int uint;
int input(int a[]);
void output(int size, int a[]);
int compression(int a[], int b[], int N);

int main()
{
    int data_a[size_arr] = { 0 }, data_b[size_arr] = { 0 }, i = 0;
    i = input(data_a);
    output(compression(data_a, data_b, i), data_b);
    return 0;
}

int input(int a[])
{
    int i = 0, fl = 0, c = 0, data[6] = { 0 }, neg = 1;
    while (c != '\n' && i < size_arr)
    {
        c = getchar();
        if ((c != ' ' && c != '\n' && c != '-'))
            data[fl++] = c;
        else if (c == ' ' || c == '\n')
        {
            for (uint n = 0; n < fl; n++)
            {
                if (fl > 1)
                    a[i] *= 10;
                a[i] += data[n] - '0';
            }
            a[i] *= neg;
            i++;
            fl = 0;
            neg = 1;
        }
        else if (c == '-')
            neg = -1;
    }
    return i;
}

void output(int size, int a[])
{
    while (size--)
        printf("%d ", *a++);
}

#endif

int compression(int a[], int b[], int N)
{
    int count = 0, fl = 0, tmp = *a;
    while (N--)
    {
        if (tmp != *a)
            count++;
        if (!fl && *a == 1)
            b[count++] = 0;
        fl = 1;
        if (*a)
            b[count]++;
        else
            b[count]++;
        tmp = *a; 
        a++;
    }
    return count+1;
}